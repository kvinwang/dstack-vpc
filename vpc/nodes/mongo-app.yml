services:
  dstack-mesh:
    image: kvin/dstack-mesh:latest
    container_name: dstack-mesh
    restart: unless-stopped
    privileged: true
    environment:
      - LOAD_MISSING_MODULES=yes
    volumes:
      - /dstack:/dstack
      - /var/run/dstack.sock:/var/run/dstack.sock

  bootstrap-agent:
    image: alpine:latest
    container_name: bootstrap-agent
    environment:
      - NODE_TYPE=app
      - NODE_NAME=app-${APP_IND}
      - VPC_SERVER_APP_ID=${VPC_SERVER_APP_ID}
    volumes:
      - shared_config:/shared
    configs:
      - source: bootstrap_script
        target: /bootstrap.sh
        mode: 0755
    command: sh -c "apk add --no-cache curl jq && /bootstrap.sh"
    restart: "no"
    depends_on:
      dstack-mesh:
        condition: service_healthy

  tailscale:
    image: tailscale/tailscale:latest
    container_name: tailscale
    restart: unless-stopped
    cap_add:
      - NET_ADMIN
      - SYS_MODULE
    devices:
      - /dev/net/tun:/dev/net/tun
    network_mode: host
    volumes:
      - shared_config:/shared:ro
      - tailscale_data:/var/lib/tailscale
      - /var/run:/var/run
    configs:
      - source: tailscale_script
        target: /tailscale-start.sh
        mode: 0755
    environment:
      - NODE_NAME=app-${APP_IND}
    command: /tailscale-start.sh
    healthcheck:
      test: ["CMD", "tailscale", "status"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    depends_on:
      bootstrap-agent:
        condition: service_completed_successfully

  app:
    image: node:18-alpine
    container_name: app
    restart: unless-stopped
    working_dir: /app
    volumes:
      - shared_config:/shared:ro
    configs:
      - source: app_script
        target: /app/app.js
        mode: 0644
      - source: app_package_json
        target: /app/package.json
        mode: 0644
      - source: app_start_script
        target: /start.sh
        mode: 0755
    command: /start.sh
    dns:
      - 100.100.100.100
    dns_search:
      - dstack.internal
    depends_on:
      tailscale:
        condition: service_healthy

volumes:
  shared_config:
  tailscale_data:
  mongodb_data:
  mongodb_config:

configs:
  bootstrap_script:
    content: |
      #!/bin/sh
      set -e

      echo "Fetching instance info from dstack-mesh..."
      INFO=$$(curl -s http://dstack-mesh/info)
      INSTANCE_ID=$$(echo "$$INFO" | jq -r .instance_id)
      echo "Instance ID: $$INSTANCE_ID"
      echo "App ID: $$VPC_SERVER_APP_ID"

      RESPONSE=$$(curl -s -H "x-dstack-target-app: $$VPC_SERVER_APP_ID" \
        "http://dstack-mesh/api/bootstrap?instance_id=$$INSTANCE_ID&node_type=$$NODE_TYPE&node_name=$$NODE_NAME")

      PRE_AUTH_KEY=$$(echo "$$RESPONSE" | jq -r .pre_auth_key)
      KEYFILE=$$(echo "$$RESPONSE" | jq -r .keyfile)
      HEADSCALE_URL=$$(echo "$$RESPONSE" | jq -r .headscale_url)

      if [ -z "$$PRE_AUTH_KEY" ] || [ -z "$$KEYFILE" ] || [ -z "$$HEADSCALE_URL" ]; then
        echo "Error: Missing required fields in response"
        echo "Response: $$RESPONSE"
        exit 1
      fi

      echo "$$PRE_AUTH_KEY" > /shared/pre_auth_key
      echo "$$KEYFILE" > /shared/keyfile
      echo "$$HEADSCALE_URL" > /shared/headscale_url

      echo "Bootstrap completed"

  tailscale_script:
    content: |
      #!/bin/sh
      set -e

      echo 'Waiting for bootstrap files...'
      while [ ! -f /shared/pre_auth_key ] || [ ! -f /shared/headscale_url ]; do
        sleep 2
      done

      PRE_AUTH_KEY=$$(cat /shared/pre_auth_key)
      HEADSCALE_URL=$$(cat /shared/headscale_url)

      echo 'Starting Tailscale with:'
      echo "  Server: $$HEADSCALE_URL"
      echo "  Hostname: $$NODE_NAME"

      tailscaled --state=/var/lib/tailscale/tailscaled.state --socket=/var/run/tailscale/tailscaled.sock &
      sleep 3

      tailscale up \
        --login-server="$$HEADSCALE_URL" \
        --authkey="$$PRE_AUTH_KEY" \
        --hostname="$$NODE_NAME" \
        --reset \
        --accept-dns

      echo 'Tailscale connected successfully'
      tail -f /dev/null

  app_start_script:
    content: |
      #!/bin/sh
      set -e

      echo 'Installing dependencies...'
      npm install

      echo 'Waiting for keyfile...'
      while [ ! -f /shared/keyfile ]; do
        sleep 1
      done

      echo 'Starting demo app...'
      node app.js

  app_package_json:
    content: |
      {
        "name": "mongodb-demo",
        "version": "1.0.0",
        "dependencies": {
          "mongodb": "^6.3.0"
        }
      }

  app_script:
    content: |
      const { MongoClient } = require('mongodb');
      const fs = require('fs');

      async function main() {
        try {
          // Derive password from keyfile
          const keyfile = fs.readFileSync('/shared/keyfile');
          const password = keyfile.subarray(0, 32).toString('base64');
          const uri = `mongodb://admin:$${password}@mongodb-0.dstack.internal:27017,mongodb-1.dstack.internal:27017,mongodb-2.dstack.internal:27017/demo?replicaSet=mongodb-cluster&authSource=admin`;
          const client = new MongoClient(uri);
          for (let i = 0; i < 10; i++) {
            try {
              console.log('Connecting to MongoDB cluster...');
              await client.connect();
              console.log('Connected to MongoDB cluster');
              break;
            } catch (error) {
              console.error('Failed to connect to MongoDB cluster:', error);
              await new Promise(resolve => setTimeout(resolve, 5000));
            }
          }

          const db = client.db('demo');
          const collection = db.collection('test');

          // Insert a test document
          const result = await collection.insertOne({
            message: 'Hello from demo app!',
            timestamp: new Date(),
            hostname: require('os').hostname()
          });

          console.log('Inserted document:', result.insertedId);

          // Read back the documents
          const docs = await collection.find({}).toArray();
          console.log('All documents:', docs);

          // Keep running and insert a document every 30 seconds
          setInterval(async () => {
            try {
              const result = await collection.insertOne({
                message: 'Periodic update',
                timestamp: new Date(),
                hostname: require('os').hostname()
              });
              console.log('Periodic insert:', result.insertedId);
            } catch (error) {
              console.error('Periodic insert error:', error);
            }
          }, 30000);

        } catch (error) {
          console.error('Error:', error);
          process.exit(1);
        }
      }

      main();
